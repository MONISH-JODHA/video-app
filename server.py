import flask
from flask import Flask, request, redirect, url_for, render_template, session, jsonify, flash
from flask_cors import CORS
import os
import sqlite3
from functools import wraps
import random
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from dotenv import load_dotenv
from flask_socketio import SocketIO, emit, join_room, leave_room

# Imports for Google Calendar API
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow # For initial auth if needed
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
import datetime # Note: datetime was already imported by Flask implicitly, but good to have explicitly
import os.path # For checking if token.json exists

load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv('FLASK_SECRET_KEY', 'a_very_secure_default_secret_key_123!PleaseChange')
CORS(app, supports_credentials=True)
socketio = SocketIO(app, cors_allowed_origins="*")

APP_EMAIL_SENDER = os.getenv('EMAIL_USER')
APP_EMAIL_PASSWORD = os.getenv('PASSWORD')
DB_PATH = './users.db'

video_rooms = {} # Stores {room_id: {sid: name, ...}}

# --- Google Calendar API Setup ---
SCOPES = ['https://www.googleapis.com/auth/calendar.events']
CLIENT_SECRET_FILE = 'client_secret.json'
TOKEN_FILE = 'token.json'

def get_calendar_service():
    creds = None
    if os.path.exists(TOKEN_FILE):
        try:
            creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)
        except Exception as e:
            print(f"Error loading credentials from {TOKEN_FILE}: {e}")
            creds = None
            
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
                print("Google Calendar token refreshed.")
            except Exception as e:
                print(f"Error refreshing Google Calendar token: {e}. Re-authentication might be needed.")
                creds = None
        else:
            # This part is problematic for a long-running server.
            # Initial token.json should ideally be generated by a separate script or a proper web OAuth flow.
            print(f"Missing or invalid {TOKEN_FILE}. Manual generation or a web OAuth flow is required.")
            if not os.path.exists(CLIENT_SECRET_FILE):
                print(f"CRITICAL: {CLIENT_SECRET_FILE} not found. Cannot authenticate with Google Calendar.")
                return None
            # For a server, you would redirect to flow.authorization_url() and handle the callback.
            # The InstalledAppFlow is mainly for CLI tools.
            # flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRET_FILE, SCOPES)
            # creds = flow.run_local_server(port=0) # This would block and open a browser
            print("Skipping automatic token generation in server context.")
            creds = None # Explicitly set to None if auth can't proceed

        if creds and os.path.exists(CLIENT_SECRET_FILE): # Save token if it was created/refreshed
            try:
                with open(TOKEN_FILE, 'w') as token_file_handle:
                    token_file_handle.write(creds.to_json())
                print(f"Google Calendar token saved to {TOKEN_FILE}")
            except Exception as e:
                print(f"Error writing token to {TOKEN_FILE}: {e}")
    
    if creds and creds.valid:
        try:
            service = build('calendar', 'v3', credentials=creds)
            print("Google Calendar service built successfully.")
            return service
        except Exception as e:
            print(f"Error building Google Calendar service: {e}")
            return None
    else:
        print("Could not obtain valid credentials for Google Calendar service.")
        return None


def init_db():
    with sqlite3.connect(DB_PATH) as conn:
        conn.execute('''CREATE TABLE IF NOT EXISTS users (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            username TEXT UNIQUE NOT NULL,
                            password TEXT NOT NULL,
                            otp TEXT,
                            verified INTEGER DEFAULT 0
                        )''')
        conn.commit()
    print(f"User database initialized at {DB_PATH}")

def is_valid_email(email_address): # Renamed parameter for clarity
    return email_address and email_address.endswith('@cloudkeeper.com')

def send_otp_email(to_email, otp):
    if not APP_EMAIL_SENDER or not APP_EMAIL_PASSWORD:
        print("ERROR: Email credentials not configured for OTP.")
        return False
    msg = MIMEMultipart('alternative')
    msg['Subject'] = 'CloudKeeper - Your Verification OTP'
    msg['From'] = f'CloudKeeper Support <{APP_EMAIL_SENDER}>'
    msg['To'] = to_email
    text = f"Your CloudKeeper OTP is: {otp}\nValid for 10 minutes."
    html = f"""<html><body><p>Your CloudKeeper OTP is: <b>{otp}</b></p><p>Valid for 10 minutes.</p></body></html>"""
    msg.attach(MIMEText(text, 'plain'))
    msg.attach(MIMEText(html, 'html'))
    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(APP_EMAIL_SENDER, APP_EMAIL_PASSWORD)
            server.sendmail(msg['From'], [msg['To']], msg.as_string())
            print(f"OTP email sent to {to_email}.")
            return True
    except Exception as e:
        print(f"Failed to send OTP to {to_email}: {e}")
        return False

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'username' not in session:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for('welcome'))
        with sqlite3.connect(DB_PATH) as conn:
            conn.row_factory = sqlite3.Row
            user = conn.execute("SELECT verified FROM users WHERE username = ?", (session['username'],)).fetchone()
            if not user or not user['verified']:
                session.pop('username', None)
                flash("Account not verified. Please verify or log in again.", "danger")
                return redirect(url_for('welcome'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/', methods=['GET'])
def welcome():
    current_year = datetime.datetime.now().year
    if 'username' in session:
        with sqlite3.connect(DB_PATH) as conn:
            conn.row_factory = sqlite3.Row
            user = conn.execute("SELECT verified FROM users WHERE username = ?", (session['username'],)).fetchone()
            if user and user['verified']:
                return redirect(url_for('video_chat_landing_page'))
            else:
                session.pop('username', None)
                flash("Your session was invalid or account is not verified. Please log in.", "warning")
    return render_template('welcome.html', year=current_year)

@app.route('/handle_email', methods=['POST'])
def handle_email():
    email = request.form.get('email', '').strip().lower()
    if not is_valid_email(email):
        flash("Invalid email. Must be a @cloudkeeper.com address.", "error")
        return redirect(url_for('welcome'))
    with sqlite3.connect(DB_PATH) as conn:
        conn.row_factory = sqlite3.Row
        user = conn.execute("SELECT * FROM users WHERE username = ?", (email,)).fetchone()
    if user:
        if user['verified']:
            session['login_email'] = email
            return redirect(url_for('enter_password'))
        else:
            otp = str(random.randint(100000, 999999))
            with sqlite3.connect(DB_PATH) as conn_update:
                 conn_update.execute("UPDATE users SET otp = ? WHERE username = ?", (otp, email))
                 conn_update.commit()
            if send_otp_email(email, otp): flash("Account not verified. A new OTP has been sent.", "info")
            else: flash("Account not verified. Failed to send OTP.", "error")
            session['pending_verification_email'] = email
            return redirect(url_for('verify_otp_page'))
    else:
        session['signup_email'] = email
        return redirect(url_for('create_account'))

@app.route('/enter_password', methods=['GET', 'POST'])
def enter_password():
    email = session.get('login_email')
    if not email: flash("Session expired. Please start over.", "warning"); return redirect(url_for('welcome'))
    if request.method == 'POST':
        password = request.form.get('password', '')
        with sqlite3.connect(DB_PATH) as conn:
            conn.row_factory = sqlite3.Row
            user = conn.execute("SELECT * FROM users WHERE username = ? AND password = ?", (email, password)).fetchone()
        if user and user['verified']:
            session['username'] = user['username']; session.pop('login_email', None)
            flash(f"Welcome back, {user['username']}!", "success"); return redirect(url_for('video_chat_landing_page'))
        elif user and not user['verified']:
            flash("Account not verified. Please verify.", "warning"); session['pending_verification_email'] = email
            return redirect(url_for('verify_otp_page'))
        else: flash("Invalid password or account issue.", "error")
    return render_template('enter_password.html', email=email, year=datetime.datetime.now().year)

@app.route('/create_account', methods=['GET', 'POST'])
def create_account():
    email = session.get('signup_email')
    if not email: flash("Session expired. Please start over.", "warning"); return redirect(url_for('welcome'))
    if request.method == 'POST':
        password = request.form.get('password', ''); confirm_password = request.form.get('confirm_password', '')
        if not password or len(password) < 4: flash("Password must be >= 4 chars.", "error"); return render_template('create_account.html', email=email, year=datetime.datetime.now().year)
        if password != confirm_password: flash("Passwords do not match.", "error"); return render_template('create_account.html', email=email, year=datetime.datetime.now().year)
        otp = str(random.randint(100000, 999999))
        try:
            with sqlite3.connect(DB_PATH) as conn:
                conn.execute("INSERT INTO users (username, password, otp, verified) VALUES (?, ?, ?, 0)", (email, password, otp))
                conn.commit()
            if send_otp_email(email, otp):
                session.pop('signup_email', None); session['pending_verification_email'] = email
                flash("Account created. Check email for OTP.", "success"); return redirect(url_for('verify_otp_page'))
            else: flash("Account created, but failed to send OTP.", "error"); return render_template('create_account.html', email=email, year=datetime.datetime.now().year)
        except sqlite3.IntegrityError: flash("Email already registered.", "error"); session.pop('signup_email', None); return redirect(url_for('welcome'))
        except Exception as e: print(f"Create account error: {e}"); flash(f"An unexpected error occurred: {e}", "error"); return render_template('create_account.html', email=email, year=datetime.datetime.now().year)
    return render_template('create_account.html', email=email, year=datetime.datetime.now().year)

@app.route('/verify_otp', methods=['GET', 'POST'])
def verify_otp_page():
    email_for_template = request.form.get('email_for_verification_fallback', session.get('pending_verification_email', ''))
    if request.method == 'GET' and not session.get('pending_verification_email'): flash("No pending verification.", "info"); return redirect(url_for('welcome'))
    if request.method == 'POST':
        otp_input = request.form.get('otp', '').strip()
        email_to_verify = request.form.get('email_for_verification_fallback', session.get('pending_verification_email', ''))
        if not email_to_verify: flash("Could not determine email for OTP. Start over.", "error"); return redirect(url_for('welcome'))
        if not otp_input: flash("OTP required.", "error"); return render_template('verify.html', email=email_to_verify, year=datetime.datetime.now().year)
        with sqlite3.connect(DB_PATH) as conn:
            conn.row_factory = sqlite3.Row
            user = conn.execute("SELECT * FROM users WHERE username = ?", (email_to_verify,)).fetchone()
            if user and not user['verified'] and user['otp'] == otp_input:
                conn.execute("UPDATE users SET verified = 1, otp = NULL WHERE username = ?", (email_to_verify,)); conn.commit()
                session.pop('pending_verification_email', None); flash("Email verified! Please log in.", "success"); return redirect(url_for('welcome'))
            elif user and user['verified']: session.pop('pending_verification_email', None); flash("Account already verified. Log in.", "info"); return redirect(url_for('welcome'))
            else: flash("Invalid OTP.", "error"); return render_template('verify.html', email=email_to_verify, year=datetime.datetime.now().year)
    return render_template('verify.html', email=email_for_template, year=datetime.datetime.now().year)

@app.route('/logout')
def logout(): session.clear(); flash("Logged out.", "info"); return redirect(url_for('welcome'))

@app.route('/video_chat_landing_page')
def video_chat_landing_page(): return render_template('video_chat.html')


@socketio.on('connect', namespace='/video')
def video_handle_connect():
    print(f"Video client connected: {request.sid}")

@socketio.on('disconnect', namespace='/video')
def video_handle_disconnect():
    user_sid_leaving = request.sid; room_left = None; user_name_leaving = "Unknown"
    print(f"Video client disconnecting: {user_sid_leaving}")
    for room_id, occupants in list(video_rooms.items()):
        if user_sid_leaving in occupants:
            user_name_leaving = occupants.pop(user_sid_leaving)
            room_left = room_id; leave_room(room_id, sid=user_sid_leaving, namespace='/video')
            print(f"User {user_name_leaving} ({user_sid_leaving}) left video room {room_id}")
            socketio.emit('user-left', {'sid': user_sid_leaving, 'name': user_name_leaving}, room=room_id, namespace='/video')
            if not occupants: del video_rooms[room_id]; print(f"Video room {room_id} is empty and removed.")
            break
    if not room_left: print(f"User {user_sid_leaving} disconnected; not found in any active room.")

@socketio.on('join', namespace='/video')
def video_on_join(data):
    room_id = data.get('room'); user_name = data.get('name', f"Guest_{request.sid[:4]}")
    if not room_id: emit('error', {'message': 'Room ID is required'}); return
    join_room(room_id, sid=request.sid, namespace='/video')
    if room_id not in video_rooms: video_rooms[room_id] = {}
    other_users_info = [{'sid': sid, 'name': name} for sid, name in video_rooms[room_id].items() if sid != request.sid]
    if other_users_info: emit('other-users', {'users': other_users_info})
    video_rooms[room_id][request.sid] = user_name
    socketio.emit('user-joined', {'sid': request.sid, 'name': user_name}, room=room_id, namespace='/video', skip_sid=request.sid)
    print(f"User {user_name} ({request.sid}) joined room {room_id}. Occupants: {len(video_rooms[room_id])}")
    emit('joined-room', {'room_id': room_id, 'sid': request.sid})

@socketio.on('signal', namespace='/video')
def video_on_signal(data):
    target_sid = data.get('target_sid')
    if not target_sid: print("Signal error: Missing target_sid"); return
    sender_name = next((occupants[request.sid] for occupants in video_rooms.values() if request.sid in occupants), "Unknown")
    message_to_send = {'sender_sid': request.sid, 'sender_name': sender_name, 'type': data.get('type'), 'payload': data.get('payload')}
    socketio.emit('signal', message_to_send, room=target_sid, namespace='/video')

@socketio.on('subtitle-text', namespace='/video')
def video_handle_subtitle_text(data):
    room_id = data.get('room'); text = data.get('text'); sender_sid = request.sid
    user_name = video_rooms.get(room_id, {}).get(sender_sid, data.get('name', f"User_{sender_sid[:4]}"))
    if room_id and text: socketio.emit('new-subtitle', {'text': text, 'sender_sid': sender_sid, 'name': user_name}, room=room_id, namespace='/video', skip_sid=sender_sid)

@socketio.on('leave', namespace='/video')
def video_on_leave(data):
    room_id = data.get('room'); user_sid_leaving = request.sid; user_name_leaving = "Unknown"
    if room_id and room_id in video_rooms and user_sid_leaving in video_rooms[room_id]:
        user_name_leaving = video_rooms[room_id].pop(user_sid_leaving)
        leave_room(room_id, sid=user_sid_leaving, namespace='/video')
        print(f"User {user_name_leaving} ({user_sid_leaving}) explicitly left room {room_id}")
        socketio.emit('user-left', {'sid': user_sid_leaving, 'name': user_name_leaving}, room=room_id, namespace='/video')
        if not video_rooms[room_id]: del video_rooms[room_id]; print(f"Video room {room_id} empty and removed.")
        emit('left-room-ack', {'room_id': room_id, 'message': 'You have left the room.'})
    else: print(f"User {user_sid_leaving} tried to explicitly leave room {room_id} but was not found/invalid.")


@socketio.on('share-room-by-email', namespace='/video')
def handle_share_room_by_email(data):
    recipient_email = data.get('recipient_email')
    room_id = data.get('room_id')
    join_link = data.get('join_link')
    sharer_name = data.get('sharer_name', 'A colleague')
    sharer_email = session.get('username', APP_EMAIL_SENDER)

    if not all([recipient_email, room_id, join_link]):
        emit('share-room-status', {'success': False, 'message': 'Missing required share information.'})
        return

    subject = f"Invitation to CloudKeeper Video Meeting: Room {room_id}"
    body_text = f"Hello,\n\n{sharer_name} has invited you to a CloudKeeper video meeting.\n\nRoom ID: {room_id}\nJoin Link: {join_link}\n\nBest regards,\nThe CloudKeeper Team (via {sharer_name})"
    body_html = f"<html><body><p>Hello,</p><p>{sharer_name} has invited you to a CloudKeeper video meeting.</p><p><strong>Room ID:</strong> {room_id}</p><p><strong>Join Link:</strong> <a href=\"{join_link}\">{join_link}</a></p><p>Best regards,<br>The CloudKeeper Team (via {sharer_name})</p></body></html>"
    msg = MIMEMultipart('alternative'); msg['Subject'] = subject; msg['From'] = f'CloudKeeper Invitations <{APP_EMAIL_SENDER}>'; msg['To'] = recipient_email
    msg.attach(MIMEText(body_text, 'plain')); msg.attach(MIMEText(body_html, 'html'))

    email_sent_successfully = False
    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls(); server.login(APP_EMAIL_SENDER, APP_EMAIL_PASSWORD)
            server.sendmail(msg['From'], [recipient_email], msg.as_string())
        print(f"Invitation email sent to {recipient_email} for room {room_id}.")
        email_sent_successfully = True
    except Exception as e:
        print(f"Failed to send invitation email to {recipient_email}: {e}")
        emit('share-room-status', {'success': False, 'message': f'Failed to send email: An error occurred.'})
        return

    if not email_sent_successfully: return

    calendar_service = get_calendar_service()
    if calendar_service:
        now = datetime.datetime.utcnow(); start_time = now.isoformat() + 'Z'; end_time = (now + datetime.timedelta(hours=1)).isoformat() + 'Z'
        event_summary = f'CloudKeeper Meeting - Room: {room_id}'
        event_description = f'Join the CloudKeeper video meeting.\nRoom ID: {room_id}\nJoin Link: {join_link}'
        event_attendees = [{'email': recipient_email}]
        if sharer_email and sharer_email != APP_EMAIL_SENDER : # Add sharer if they are a logged-in user (not the app's default sender)
            event_attendees.append({'email': sharer_email})
        
        event = {
            'summary': event_summary, 'location': f'CloudKeeper Video Call - Room {room_id}', 'description': event_description,
            'start': {'dateTime': start_time, 'timeZone': 'UTC'}, 'end': {'dateTime': end_time, 'timeZone': 'UTC'},
            'attendees': event_attendees,
            'reminders': {'useDefault': False, 'overrides': [{'method': 'popup', 'minutes': 10}]}
        }
        try:
            created_event = calendar_service.events().insert(calendarId='primary', body=event, sendUpdates='all').execute()
            print(f"Calendar event created: {created_event.get('htmlLink')}")
            emit('share-room-status', {'success': True, 'message': 'Invitation sent & calendar event created!'})
        except Exception as e:
            print(f"Error creating calendar event: {e}")
            emit('share-room-status', {'success': True, 'message': f'Email sent, but failed to create calendar event: {e}'})
    else:
        print("Calendar service not available. Skipping event creation.")
        emit('share-room-status', {'success': True, 'message': 'Invitation email sent. Calendar event skipped (auth/service issue).'})


if __name__ == '__main__':
    init_db()
    print("Starting Flask-SocketIO server on http://localhost:5000")
    socketio.run(app, debug=True, host='0.0.0.0', port=5000)